// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: sms/v1/simple_message.proto

package v1

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on Authentication with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Authentication) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Authentication with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in AuthenticationMultiError,
// or nil if none found.
func (m *Authentication) ValidateAll() error {
	return m.validate(true)
}

func (m *Authentication) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetAppId()) != 16 {
		err := AuthenticationValidationError{
			field:  "AppId",
			reason: "value length must be 16 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)

	}

	if utf8.RuneCountInString(m.GetToken()) != 64 {
		err := AuthenticationValidationError{
			field:  "Token",
			reason: "value length must be 64 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)

	}

	if len(errors) > 0 {
		return AuthenticationMultiError(errors)
	}

	return nil
}

// AuthenticationMultiError is an error wrapping multiple validation errors
// returned by Authentication.ValidateAll() if the designated constraints
// aren't met.
type AuthenticationMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AuthenticationMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AuthenticationMultiError) AllErrors() []error { return m }

// AuthenticationValidationError is the validation error returned by
// Authentication.Validate if the designated constraints aren't met.
type AuthenticationValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AuthenticationValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AuthenticationValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AuthenticationValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AuthenticationValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AuthenticationValidationError) ErrorName() string { return "AuthenticationValidationError" }

// Error satisfies the builtin error interface
func (e AuthenticationValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAuthentication.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AuthenticationValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AuthenticationValidationError{}

// Validate checks the field values on TextMessageRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TextMessageRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TextMessageRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TextMessageRequestMultiError, or nil if none found.
func (m *TextMessageRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *TextMessageRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetAuth()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TextMessageRequestValidationError{
					field:  "Auth",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TextMessageRequestValidationError{
					field:  "Auth",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAuth()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TextMessageRequestValidationError{
				field:  "Auth",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if l := utf8.RuneCountInString(m.GetContent()); l < 1 || l > 255 {
		err := TextMessageRequestValidationError{
			field:  "Content",
			reason: "value length must be between 1 and 255 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if val := m.GetPriority(); val < 0 || val > 9 {
		err := TextMessageRequestValidationError{
			field:  "Priority",
			reason: "value must be inside range [0, 9]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := len(m.GetPhones()); l < 1 || l > 99 {
		err := TextMessageRequestValidationError{
			field:  "Phones",
			reason: "value must contain between 1 and 99 items, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	_TextMessageRequest_Phones_Unique := make(map[string]struct{}, len(m.GetPhones()))

	for idx, item := range m.GetPhones() {
		_, _ = idx, item

		if _, exists := _TextMessageRequest_Phones_Unique[item]; exists {
			err := TextMessageRequestValidationError{
				field:  fmt.Sprintf("Phones[%v]", idx),
				reason: "repeated value must contain unique items",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		} else {
			_TextMessageRequest_Phones_Unique[item] = struct{}{}
		}

		// no validation rules for Phones[idx]
	}

	if m.AtTime != nil {

		if all {
			switch v := interface{}(m.GetAtTime()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TextMessageRequestValidationError{
						field:  "AtTime",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TextMessageRequestValidationError{
						field:  "AtTime",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetAtTime()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TextMessageRequestValidationError{
					field:  "AtTime",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return TextMessageRequestMultiError(errors)
	}

	return nil
}

// TextMessageRequestMultiError is an error wrapping multiple validation errors
// returned by TextMessageRequest.ValidateAll() if the designated constraints
// aren't met.
type TextMessageRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TextMessageRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TextMessageRequestMultiError) AllErrors() []error { return m }

// TextMessageRequestValidationError is the validation error returned by
// TextMessageRequest.Validate if the designated constraints aren't met.
type TextMessageRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TextMessageRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TextMessageRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TextMessageRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TextMessageRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TextMessageRequestValidationError) ErrorName() string {
	return "TextMessageRequestValidationError"
}

// Error satisfies the builtin error interface
func (e TextMessageRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTextMessageRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TextMessageRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TextMessageRequestValidationError{}

// Validate checks the field values on TemplateMessageRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TemplateMessageRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TemplateMessageRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TemplateMessageRequestMultiError, or nil if none found.
func (m *TemplateMessageRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *TemplateMessageRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetAuth()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TemplateMessageRequestValidationError{
					field:  "Auth",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TemplateMessageRequestValidationError{
					field:  "Auth",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAuth()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TemplateMessageRequestValidationError{
				field:  "Auth",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if utf8.RuneCountInString(m.GetTemplateId()) != 6 {
		err := TemplateMessageRequestValidationError{
			field:  "TemplateId",
			reason: "value length must be 6 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)

	}

	if l := len(m.GetPhones()); l < 1 || l > 99 {
		err := TemplateMessageRequestValidationError{
			field:  "Phones",
			reason: "value must contain between 1 and 99 items, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	_TemplateMessageRequest_Phones_Unique := make(map[string]struct{}, len(m.GetPhones()))

	for idx, item := range m.GetPhones() {
		_, _ = idx, item

		if _, exists := _TemplateMessageRequest_Phones_Unique[item]; exists {
			err := TemplateMessageRequestValidationError{
				field:  fmt.Sprintf("Phones[%v]", idx),
				reason: "repeated value must contain unique items",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		} else {
			_TemplateMessageRequest_Phones_Unique[item] = struct{}{}
		}

		// no validation rules for Phones[idx]
	}

	if l := len(m.GetArgs()); l < 1 || l > 16 {
		err := TemplateMessageRequestValidationError{
			field:  "Args",
			reason: "value must contain between 1 and 16 pairs, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	{
		sorted_keys := make([]string, len(m.GetArgs()))
		i := 0
		for key := range m.GetArgs() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetArgs()[key]
			_ = val

			// no validation rules for Args[key]

			if utf8.RuneCountInString(val) > 64 {
				err := TemplateMessageRequestValidationError{
					field:  fmt.Sprintf("Args[%v]", key),
					reason: "value length must be at most 64 runes",
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}

		}
	}

	if m.AtTime != nil {

		if all {
			switch v := interface{}(m.GetAtTime()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TemplateMessageRequestValidationError{
						field:  "AtTime",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TemplateMessageRequestValidationError{
						field:  "AtTime",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetAtTime()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TemplateMessageRequestValidationError{
					field:  "AtTime",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return TemplateMessageRequestMultiError(errors)
	}

	return nil
}

// TemplateMessageRequestMultiError is an error wrapping multiple validation
// errors returned by TemplateMessageRequest.ValidateAll() if the designated
// constraints aren't met.
type TemplateMessageRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TemplateMessageRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TemplateMessageRequestMultiError) AllErrors() []error { return m }

// TemplateMessageRequestValidationError is the validation error returned by
// TemplateMessageRequest.Validate if the designated constraints aren't met.
type TemplateMessageRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TemplateMessageRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TemplateMessageRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TemplateMessageRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TemplateMessageRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TemplateMessageRequestValidationError) ErrorName() string {
	return "TemplateMessageRequestValidationError"
}

// Error satisfies the builtin error interface
func (e TemplateMessageRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTemplateMessageRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TemplateMessageRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TemplateMessageRequestValidationError{}

// Validate checks the field values on AsyncResultQueryRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AsyncResultQueryRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AsyncResultQueryRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AsyncResultQueryRequestMultiError, or nil if none found.
func (m *AsyncResultQueryRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *AsyncResultQueryRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetAuth()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AsyncResultQueryRequestValidationError{
					field:  "Auth",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AsyncResultQueryRequestValidationError{
					field:  "Auth",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAuth()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AsyncResultQueryRequestValidationError{
				field:  "Auth",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.GetQueryId() <= 0 {
		err := AsyncResultQueryRequestValidationError{
			field:  "QueryId",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return AsyncResultQueryRequestMultiError(errors)
	}

	return nil
}

// AsyncResultQueryRequestMultiError is an error wrapping multiple validation
// errors returned by AsyncResultQueryRequest.ValidateAll() if the designated
// constraints aren't met.
type AsyncResultQueryRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AsyncResultQueryRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AsyncResultQueryRequestMultiError) AllErrors() []error { return m }

// AsyncResultQueryRequestValidationError is the validation error returned by
// AsyncResultQueryRequest.Validate if the designated constraints aren't met.
type AsyncResultQueryRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AsyncResultQueryRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AsyncResultQueryRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AsyncResultQueryRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AsyncResultQueryRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AsyncResultQueryRequestValidationError) ErrorName() string {
	return "AsyncResultQueryRequestValidationError"
}

// Error satisfies the builtin error interface
func (e AsyncResultQueryRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAsyncResultQueryRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AsyncResultQueryRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AsyncResultQueryRequestValidationError{}

// Validate checks the field values on ReplyStatus with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ReplyStatus) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReplyStatus with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ReplyStatusMultiError, or
// nil if none found.
func (m *ReplyStatus) ValidateAll() error {
	return m.validate(true)
}

func (m *ReplyStatus) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	if len(errors) > 0 {
		return ReplyStatusMultiError(errors)
	}

	return nil
}

// ReplyStatusMultiError is an error wrapping multiple validation errors
// returned by ReplyStatus.ValidateAll() if the designated constraints aren't met.
type ReplyStatusMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReplyStatusMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReplyStatusMultiError) AllErrors() []error { return m }

// ReplyStatusValidationError is the validation error returned by
// ReplyStatus.Validate if the designated constraints aren't met.
type ReplyStatusValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReplyStatusValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReplyStatusValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReplyStatusValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReplyStatusValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReplyStatusValidationError) ErrorName() string { return "ReplyStatusValidationError" }

// Error satisfies the builtin error interface
func (e ReplyStatusValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReplyStatus.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReplyStatusValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReplyStatusValidationError{}

// Validate checks the field values on SendMessageReply with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *SendMessageReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SendMessageReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SendMessageReplyMultiError, or nil if none found.
func (m *SendMessageReply) ValidateAll() error {
	return m.validate(true)
}

func (m *SendMessageReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetStatus()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SendMessageReplyValidationError{
					field:  "Status",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SendMessageReplyValidationError{
					field:  "Status",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStatus()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SendMessageReplyValidationError{
				field:  "Status",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for QueryId

	if len(errors) > 0 {
		return SendMessageReplyMultiError(errors)
	}

	return nil
}

// SendMessageReplyMultiError is an error wrapping multiple validation errors
// returned by SendMessageReply.ValidateAll() if the designated constraints
// aren't met.
type SendMessageReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SendMessageReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SendMessageReplyMultiError) AllErrors() []error { return m }

// SendMessageReplyValidationError is the validation error returned by
// SendMessageReply.Validate if the designated constraints aren't met.
type SendMessageReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SendMessageReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SendMessageReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SendMessageReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SendMessageReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SendMessageReplyValidationError) ErrorName() string { return "SendMessageReplyValidationError" }

// Error satisfies the builtin error interface
func (e SendMessageReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSendMessageReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SendMessageReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SendMessageReplyValidationError{}

// Validate checks the field values on AsyncResultQueryReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AsyncResultQueryReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AsyncResultQueryReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AsyncResultQueryReplyMultiError, or nil if none found.
func (m *AsyncResultQueryReply) ValidateAll() error {
	return m.validate(true)
}

func (m *AsyncResultQueryReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetStatus()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AsyncResultQueryReplyValidationError{
					field:  "Status",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AsyncResultQueryReplyValidationError{
					field:  "Status",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStatus()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AsyncResultQueryReplyValidationError{
				field:  "Status",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for QueryId

	for idx, item := range m.GetResults() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, AsyncResultQueryReplyValidationError{
						field:  fmt.Sprintf("Results[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, AsyncResultQueryReplyValidationError{
						field:  fmt.Sprintf("Results[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return AsyncResultQueryReplyValidationError{
					field:  fmt.Sprintf("Results[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return AsyncResultQueryReplyMultiError(errors)
	}

	return nil
}

// AsyncResultQueryReplyMultiError is an error wrapping multiple validation
// errors returned by AsyncResultQueryReply.ValidateAll() if the designated
// constraints aren't met.
type AsyncResultQueryReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AsyncResultQueryReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AsyncResultQueryReplyMultiError) AllErrors() []error { return m }

// AsyncResultQueryReplyValidationError is the validation error returned by
// AsyncResultQueryReply.Validate if the designated constraints aren't met.
type AsyncResultQueryReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AsyncResultQueryReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AsyncResultQueryReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AsyncResultQueryReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AsyncResultQueryReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AsyncResultQueryReplyValidationError) ErrorName() string {
	return "AsyncResultQueryReplyValidationError"
}

// Error satisfies the builtin error interface
func (e AsyncResultQueryReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAsyncResultQueryReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AsyncResultQueryReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AsyncResultQueryReplyValidationError{}

// Validate checks the field values on AsyncResultQueryReply_ResultList with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *AsyncResultQueryReply_ResultList) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AsyncResultQueryReply_ResultList with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// AsyncResultQueryReply_ResultListMultiError, or nil if none found.
func (m *AsyncResultQueryReply_ResultList) ValidateAll() error {
	return m.validate(true)
}

func (m *AsyncResultQueryReply_ResultList) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Phone

	// no validation rules for SequenceId

	// no validation rules for Result

	// no validation rules for MsgId

	if all {
		switch v := interface{}(m.GetSendTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AsyncResultQueryReply_ResultListValidationError{
					field:  "SendTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AsyncResultQueryReply_ResultListValidationError{
					field:  "SendTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSendTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AsyncResultQueryReply_ResultListValidationError{
				field:  "SendTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetResponseTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AsyncResultQueryReply_ResultListValidationError{
					field:  "ResponseTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AsyncResultQueryReply_ResultListValidationError{
					field:  "ResponseTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetResponseTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AsyncResultQueryReply_ResultListValidationError{
				field:  "ResponseTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.ReportTime != nil {

		if all {
			switch v := interface{}(m.GetReportTime()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, AsyncResultQueryReply_ResultListValidationError{
						field:  "ReportTime",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, AsyncResultQueryReply_ResultListValidationError{
						field:  "ReportTime",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetReportTime()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return AsyncResultQueryReply_ResultListValidationError{
					field:  "ReportTime",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.Report != nil {
		// no validation rules for Report
	}

	if len(errors) > 0 {
		return AsyncResultQueryReply_ResultListMultiError(errors)
	}

	return nil
}

// AsyncResultQueryReply_ResultListMultiError is an error wrapping multiple
// validation errors returned by
// AsyncResultQueryReply_ResultList.ValidateAll() if the designated
// constraints aren't met.
type AsyncResultQueryReply_ResultListMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AsyncResultQueryReply_ResultListMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AsyncResultQueryReply_ResultListMultiError) AllErrors() []error { return m }

// AsyncResultQueryReply_ResultListValidationError is the validation error
// returned by AsyncResultQueryReply_ResultList.Validate if the designated
// constraints aren't met.
type AsyncResultQueryReply_ResultListValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AsyncResultQueryReply_ResultListValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AsyncResultQueryReply_ResultListValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AsyncResultQueryReply_ResultListValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AsyncResultQueryReply_ResultListValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AsyncResultQueryReply_ResultListValidationError) ErrorName() string {
	return "AsyncResultQueryReply_ResultListValidationError"
}

// Error satisfies the builtin error interface
func (e AsyncResultQueryReply_ResultListValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAsyncResultQueryReply_ResultList.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AsyncResultQueryReply_ResultListValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AsyncResultQueryReply_ResultListValidationError{}
